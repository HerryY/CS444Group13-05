Only in assign3driver/: .AppleDouble
diff -ur differ/Makefile assign3driver/Makefile
--- differ/Makefile	2017-05-28 12:28:01.459773000 -0700
+++ assign3driver/Makefile	2017-05-28 11:34:45.814700000 -0700
@@ -5,6 +5,7 @@
 # Rewritten to use lists instead of if-statements.
 # 
 
+obj-m						+= sbd.o
 obj-$(CONFIG_MAC_FLOPPY)	+= swim3.o
 obj-$(CONFIG_BLK_DEV_SWIM)	+= swim_mod.o
 obj-$(CONFIG_BLK_DEV_FD)	+= floppy.o
@@ -15,6 +16,7 @@
 obj-$(CONFIG_AMIGA_Z2RAM)	+= z2ram.o
 obj-$(CONFIG_BLK_DEV_RAM)	+= brd.o
 obj-$(CONFIG_BLK_DEV_LOOP)	+= loop.o
+obj-$(CONFIG_BLK_DEV_XD)	+= xd.o
 obj-$(CONFIG_BLK_CPQ_DA)	+= cpqarray.o
 obj-$(CONFIG_BLK_CPQ_CISS_DA)  += cciss.o
 obj-$(CONFIG_BLK_DEV_DAC960)	+= DAC960.o
@@ -22,28 +24,22 @@
 obj-$(CONFIG_CDROM_PKTCDVD)	+= pktcdvd.o
 obj-$(CONFIG_MG_DISK)		+= mg_disk.o
 obj-$(CONFIG_SUNVDC)		+= sunvdc.o
-obj-$(CONFIG_BLK_DEV_NVME)	+= nvme.o
-obj-$(CONFIG_BLK_DEV_SKD)	+= skd.o
 obj-$(CONFIG_BLK_DEV_OSD)	+= osdblk.o
+obj-$(CONFIG_RAM_DISK)		+= osurd.o
 
 obj-$(CONFIG_BLK_DEV_UMEM)	+= umem.o
 obj-$(CONFIG_BLK_DEV_NBD)	+= nbd.o
 obj-$(CONFIG_BLK_DEV_CRYPTOLOOP) += cryptoloop.o
 obj-$(CONFIG_VIRTIO_BLK)	+= virtio_blk.o
 
+obj-$(CONFIG_VIODASD)		+= viodasd.o
 obj-$(CONFIG_BLK_DEV_SX8)	+= sx8.o
+obj-$(CONFIG_BLK_DEV_UB)	+= ub.o
 obj-$(CONFIG_BLK_DEV_HD)	+= hd.o
 
 obj-$(CONFIG_XEN_BLKDEV_FRONTEND)	+= xen-blkfront.o
 obj-$(CONFIG_XEN_BLKDEV_BACKEND)	+= xen-blkback/
 obj-$(CONFIG_BLK_DEV_DRBD)     += drbd/
 obj-$(CONFIG_BLK_DEV_RBD)     += rbd.o
-obj-$(CONFIG_BLK_DEV_PCIESSD_MTIP32XX)	+= mtip32xx/
 
-obj-$(CONFIG_BLK_DEV_RSXX) += rsxx/
-obj-$(CONFIG_BLK_DEV_NULL_BLK)	+= null_blk.o
-obj-$(CONFIG_ZRAM) += zram/
-
-nvme-y		:= nvme-core.o nvme-scsi.o
-skd-y		:= skd_main.o
 swim_mod-y	:= swim.o swim_asm.o
diff -ur differ/sbd.c assign3driver/sbd.c
--- differ/sbd.c	2017-05-28 12:27:00.310444000 -0700
+++ assign3driver/sbd.c	2017-05-28 11:46:27.200306000 -0700
@@ -0,0 +1,344 @@
+/*
+ * A sample, extra-simple block driver. Updated for kernel 2.6.31.
+ *
+ * (C) 2003 Eklektix, Inc.
+ * (C) 2010 Pat Patterson <pat at superpat dot com>
+ * Redistributable under the terms of the GNU GPL.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h> /* printk() */
+#include <linux/fs.h>     /* everything... */
+#include <linux/errno.h>  /* error codes */
+#include <linux/types.h>  /* size_t */
+#include <linux/vmalloc.h>/* vmalloc */
+#include <linux/genhd.h>
+#include <linux/blkdev.h>
+#include <linux/hdreg.h>  /* HDIO_GETGEO partitioning*/
+#include <linux/slab.h>	  /* kmmalloc */
+#include <linux/fcntl.h>  /* File I/O */
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/kdev_t.h>
+#include <linux/buffer_head.h>
+#include <linux/bio.h>
+#include <linux/crypto.h>
+#include <linux/scatterlist.h>
+
+MODULE_LICENSE("GPL");
+
+static int major_num = 0;
+module_param(major_num, int, 0);
+
+static int logical_block_size = 512;
+module_param(logical_block_size, int, 0);
+
+/* Drive size */
+static int nsectors = 1024;
+module_param(nsectors, int, 0);
+
+/*
+ * We can tweak our hardware sector size, but the kernel talks to us
+ * in terms of small sectors, always.
+ */
+#define KERNEL_SECTOR_SIZE 512
+
+/*
+ * Our request queue.
+ */
+static struct request_queue *Queue;
+
+/*
+ * Device data
+ */
+static struct sbd_device {
+	unsigned long size;		/* Device size in sectors*/
+	spinlock_t lock;		/* Mutex */
+	u8 *data;				/* Data Array */
+	struct gendisk *gd; 	/* Gendisk struct */
+} Device;
+
+/* ***Note that the crypto key must be 16 characters long */
+struct crypto_cipher *tfm;
+static char *key = "1234123412341234";
+module_param(key, charp, 0644);
+static int keylen = 16;
+module_param(keylen, int, 0644);
+
+/*
+ * Handle an I/O request.
+ * param nsect - The number of sectors for reading and writing
+ * param sector - Starting sector
+ */
+static void sbd_transfer(struct sbd_device *dev, sector_t sector,
+		unsigned long nsect, char *buffer, int write) {
+	unsigned long offset = sector * logical_block_size;
+	unsigned long nbytes = nsect * logical_block_size;
+	u8 *destination;
+	u8 *source;
+
+	if (write)
+		printk("WRITE \n");
+	else
+		printk("READ\n");
+
+	if ((offset + nbytes) > dev->size) {
+		return;
+	}
+
+    crypto_cipher_setkey(tfm, key, keylen);
+
+
+	int i;
+
+	/*
+	 * Essentially we are transferring (encrypting/decrypting) data one block at
+	 * a time until we reach a specific length (n bytes)
+	 * If we are writing, then we are transferring data from the block to the device
+	 * If we are reading, then we are transferring data from the device to the block
+	 */
+
+	if (write) {
+
+		destination = dev->data + offset;
+		source = buffer;
+
+		for (i = 0; i < nbytes; i += crypto_cipher_blocksize(tfm)) {
+			/* Use crypto cipher handler and tfm to encrypt data one block at a time*/
+			crypto_cipher_encrypt_one(
+					tfm,	 				/* Cipher handler */
+					dev->data + offset + i,	/* Destination */
+					buffer + i				/* Source */
+					);
+		}
+
+		for (i = 0; i < 100; i++) {
+			printk("%u", (unsigned) *destination++);
+		}
+
+		for (i = 0; i < 100; i++) {
+			printk("%u", (unsigned) *source++);
+		}
+		printk("\n");
+	}
+	else {
+
+		destination = dev->data + offset;
+		source = buffer;
+
+		for (i = 0; i < nbytes; i += crypto_cipher_blocksize(tfm)) {
+			/* Use crypto cipher handler and tfm to decrypt data one block at a time*/
+			crypto_cipher_decrypt_one(
+					tfm,					/* Cipher handler */
+					buffer + i,				/* Destination */
+					dev->data + offset + i	/* Source */
+					);
+		}
+
+		for (i = 0; i < 100; i++) {
+			printk("%u", (unsigned) *destination++);
+		}
+
+		for (i = 0; i < 100; i++) {
+			printk("%u", (unsigned) *source++);
+		}
+		printk("\n");
+	}
+
+}
+
+static void sbd_request(struct request_queue *q) {
+	struct request *req;
+
+	/* Gets request from top of queue */
+	req = blk_fetch_request(q);
+
+	/* Iterate through queue */
+	while (req != NULL) {
+
+		/* Skip non-command requests */
+		if (req == NULL || (req->cmd_type != REQ_TYPE_FS)) {
+			__blk_end_request_all(req, -EIO);
+			continue;
+		}
+
+		sbd_transfer(&Device, 					/* Device Data */
+					blk_rq_pos(req),			/* Request Sector */
+					blk_rq_cur_sectors(req),	/* Number of sectors */
+					req->buffer, 				/* Buffer */
+					rq_data_dir(req)); 			/* Write */
+
+
+		/* Get next request */
+		if ( ! __blk_end_request_cur(req, 0) ) {
+			req = blk_fetch_request(q);
+		}
+
+	}
+}
+
+/*
+ * The HDIO_GETGEO ioctl is handled in blkdev_ioctl(), which
+ * calls this. We need to implement getgeo, since we can't
+ * use tools such as fdisk to partition the drive otherwise.
+ */
+int sbd_getgeo(struct block_device * block_device, struct hd_geometry * geo) {
+	long size;
+
+
+	/* We have no real geometry, of course, so make something up. */
+	size = Device.size * (logical_block_size / KERNEL_SECTOR_SIZE);
+	geo->cylinders = (size & ~0x3f) >> 6;
+	geo->heads = 4;
+	geo->sectors = 16;
+	geo->start = 0;
+
+
+	return 0;
+}
+
+/*
+ * The device operations structure.
+ */
+static struct block_device_operations sbd_ops = {
+		.owner  = THIS_MODULE,
+		.getgeo = sbd_getgeo
+};
+
+static int __init sbd_init(void) {
+	/* File I/O */
+	mm_segment_t oldfs;
+	struct file *filp = NULL;
+	unsigned long long offset = 0;
+	ssize_t size;
+
+
+	/* Register block device */
+	major_num = register_blkdev(major_num, "sbd");
+
+	/* Check if block device is busy */
+	if (major_num < 0) {
+		return -EBUSY;
+	}
+
+	/* Set up device and set the device to all 0s */
+	memset(&Device, 0, sizeof(struct sbd_device));
+	Device.size = nsectors * logical_block_size;
+	Device.data = vmalloc(Device.size);
+
+	memset(Device.data, 0, Device.size);
+
+	/* Check if device data is allocated */
+	if (Device.data == NULL) {
+		unregister_blkdev(major_num, "sbd");
+		return -ENOMEM;
+	}
+
+
+	/* Copy device data from a file. Create it too if it does not exist */
+	oldfs = get_fs();
+	set_fs(get_ds());
+	filp = filp_open("/Data", O_RDONLY | O_CREAT, S_IRWXUGO);
+
+
+	/* Check any errors or NULL from reading */
+	if (IS_ERR(filp)) {
+		set_fs(oldfs);
+	} else {
+
+		/* Read File */
+		size = vfs_read(filp, Device.data, Device.size, &offset);
+
+		/* Closed File */
+		set_fs(oldfs);
+		filp_close(filp, 0);
+	}
+
+	/* Initialize spin_lock */
+	spin_lock_init(&Device.lock);
+
+	/* Initialize queue and call sbd_request when requests come in */
+	Queue = blk_init_queue(sbd_request, &Device.lock);
+	if (Queue == NULL) {
+		unregister_blkdev(major_num, "sbd");
+		vfree(Device.data);
+		return -ENOMEM;
+	}
+
+	/* Set logical_block_size for queue */
+	blk_queue_logical_block_size(Queue, logical_block_size);
+
+	/* Initialize gendisk */
+	Device.gd = alloc_disk(16);
+	if (!Device.gd) {
+		unregister_blkdev(major_num, "sbd");
+		vfree(Device.data);
+		return -ENOMEM;
+	}
+
+	/* Initialize cypto and set key
+	 * ctrypto_alloc_cipher are: crypto driver name, type, and mask
+	 */
+	tfm = crypto_alloc_cipher("aes", 0, 0);
+
+    IS_ERR(tfm);
+
+	
+
+	/* And The gendisk structure */
+	Device.gd->major = major_num;
+	Device.gd->first_minor = 0;
+	Device.gd->fops = &sbd_ops;
+	Device.gd->private_data = &Device;
+	strcpy(Device.gd->disk_name, "sbd0");
+	set_capacity(Device.gd, nsectors);
+	Device.gd->queue = Queue;
+
+	/* Register partition in Device.gd with kernel */
+	add_disk(Device.gd);
+
+	return 0;
+}
+
+static void __exit sbd_exit(void)
+{
+	struct file *filp = NULL;
+	mm_segment_t oldfs;
+	ssize_t size;
+	unsigned long long offset = 0;
+
+	/* First write data to file */
+	oldfs = get_fs();
+	set_fs(get_ds());
+	filp = filp_open("/Data", O_WRONLY | O_TRUNC | O_CREAT, S_IRWXUGO);
+
+	if (IS_ERR(filp)) {
+		set_fs(oldfs);
+	} else {
+
+		/* Write the bytes to file */
+		size = vfs_write(filp, Device.data, Device.size, &offset);
+
+		/* Close File */
+		set_fs(oldfs);
+		filp_close(filp, 0);
+	}
+
+	del_gendisk(Device.gd);
+	put_disk(Device.gd);
+	unregister_blkdev(major_num, "sbd");
+	blk_cleanup_queue(Queue);
+	vfree(Device.data);
+
+	crypto_free_cipher(tfm);
+
+}
+
+module_init(sbd_init);
+module_exit(sbd_exit);
+
+MODULE_AUTHOR("Nawwaf Almutairi, Gina Phipps, Brandon Thenell");
+MODULE_DESCRIPTION("Block Device Driver");
